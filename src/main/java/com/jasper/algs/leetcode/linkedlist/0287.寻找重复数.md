<script src="https://cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

## 0287. 寻找重复数

给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），由抽屉原理可知，至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

示例 1:

```
输入: [1,3,4,2,2]
输出: 2
```

示例 2:

```
输入: [3,1,3,4,2]
输出: 3
```

说明：

1. 不能更改原数组（假设数组是只读的）。
2. 只能使用额外的 O(1) 的空间。
3. 时间复杂度小于 O(n2) 。
4. 数组中只有一个重复的数字，但它可能不止重复出现一次。


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/find-the-duplicate-number
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 模板代码

``` java
class Solution {
    public int findDuplicate(int[] nums) {

    }
}
```

### 解决方案

准备知识: [抽屉原理](抽屉原理（鸽巢原理）.md)

一些很容易想到的解法，不能满足限制：

* 暴力求解。违反限制3；
* 先排序，再处理。原址排序，违反限制1；非原址排序，违反限制2；
* 辅助字典。违反限制2；
* 不使用辅助字典，在原数组基础上，索引作哈希槽位，标记或记数。违反限制1；


#### 1. 二分查找

先猜一个数（有效范围 `[left, right]`里的中间数`mid`），然后统计原始数组中**小于等于**这个中间数`mid`的元素的个数 `cnt`。

如果 `cnt` **严格大于**`mid`，根据抽屉原理，重复元素就应该在区间 `[left, mid]` 里。

如果 `cnt` **小于等于**`mid`，那么原始数组中**严格大于**中间数`mid`的元素的个数一定**严格大于**`mid`，根据抽屉原理，重复元素就应该在区间 `[mid+1, right]` 里。

[二分查找](qu0287/solu1/Solution.java)



#### 2. 位统计

依次统计数组中每一位 1 的个数，记为 a[i]。再依次统计 1 到 n 中每一位 1 的个数，记为 b[i]。i 代表的是哪一位，因为是 int，所以范围是 0 到 32。

记重复的数字是 res。

如果 `a[i] > b[i]` 也就意味着 res 当前位是 1。

否则的话，res 当前位就是 0。


如果重复数字`res`，只重复出现一次，很容易证明，这种解法是对的。

如果重复数字`res`，不只重复出现一次，意味着有数字`p`缺失。
假设`p`的二进制数上某位，原本是`1`，那么转换成`res`后，如果对应位上也是`1`，则`a[i]`不变；如果对应位上变成了`0`，则`a[i]`减小，也就是原本`a[i] > b[i]`变成了`a[i] <= b[i]`，不影响结果。
假设`p`的二进制数上某位，原本是`0`，那么转换成`res`后，如果对应位上也是`0`，则`a[i]`不变；如果对应位上变成了`1`，则`a[i]`增大，也就是原本`a[i] > b[i]`仍然有`a[i] > b[i]`，不影响结果。

[位统计](qu0287/solu2/Solution.java)



#### 3. 快慢指针（推荐）

对于每对索引 i 和值 \\(v_i\\)​ 而言，“下一个” \\(v_j\\)​​ 位于索引 \\(v_i\\)​处，将问题转化成[循环检测问题](必知：快慢指针.md)

可以很容易地证明问题的约束意味着必须存在一个循环。因为 nums 中的每个数字都在 1 和 n 之间，所以它必须指向存在的索引。此外，由于 0 不能作为 nums 中的值出现，nums[0] 不能作为循环的一部分。

索引代表节点位置，元素值代表指针；索引相同表示指针相遇。

[快慢指针](qu0287/solu3/Solution.java)

