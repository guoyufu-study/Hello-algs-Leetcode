# 最接近的三数之和

给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

例如，

```
给定数组 nums = [-1，2，1，-4], 和 target = 1.

与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/3sum-closest
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 解决方案

### 1. 暴力求解：三层循环

三层循环，求和，比较更新。

时间复杂度O(n^3)

``` java
public int threeSumClosest(int[] nums, int target) {
	if(nums==null || nums.length<3) 
		throw new IllegalArgumentException("输入数组最少应有3个元素...");
	
	int ans=nums[0]+nums[1]+nums[2];
	for (int i = 0; i < nums.length; i++) {//三层循环
		for (int j = i+1; j < nums.length; j++) {
			for (int k = j+1; k < nums.length; k++) {
				int sum = nums[i]+nums[j]+nums[k];//求和
				if(sum==target) return target; //最接近值 target
				if(Math.abs(target-sum)<Math.abs(target-ans)) //更新答案
					ans = sum;
			}
		}
	}
	return ans;
}
```

### 2. 排序+双指针

先排序，时间复杂度O(nlog(n)).

再遍历，双指针逼近，求和，比较更新

``` java
public int threeSumClosest(int[] nums, int target) {
	if(nums==null || nums.length<3) 
		throw new IllegalArgumentException("输入数组最少应有3个元素...");
	
	Arrays.sort(nums);//排序
	
	int ans=nums[0]+nums[1]+nums[2];
	for (int i = 0; i < nums.length-2; i++) {//双指针
		int L=i+1, R=nums.length-1;
		while(L<R) {
			int sum = nums[i]+nums[L]+nums[R];
			
			if(Math.abs(target-sum)<Math.abs(target-ans)) ans=sum; //更新答案
			
			if(sum<target) L++; //小了
			else if(sum>target) R--; //大了
			else return target; //最接近值 target
		}
	}
	return ans;
}
```

### 2. 排序+（优化）双指针

先排序，时间复杂度O(nlog(n)).

再遍历，双指针逼近，求和，比较更新

避免不必要的双指针逼近。

``` java
public int threeSumClosest(int[] nums, int target) {
	if(nums==null || nums.length<3) 
		throw new IllegalArgumentException("输入数组最少应有3个元素...");
	
	Arrays.sort(nums);//排序
    
    int ans = nums[0] + nums[1] + nums[2];
    for(int i=0;i<nums.length-2;i++){//减少不必要的遍历
    	while(i>0 && i<nums.length-2 
    			&& nums[i] == nums[i-1])//去重
            i++;
    	
        int L = i+1;
        int R = nums.length - 1;
        while(L != R){
            int min = nums[i] + nums[L] + nums[L + 1];//最小和
            if(min > target ){
                if(Math.abs(ans - target) > Math.abs(min - target))
                    ans = min;
                break;
            }
            int max = nums[i] + nums[R] + nums[R - 1];//最大和
            if(target > max){
                if(Math.abs(ans - target) > Math.abs(max - target))
                    ans = max;
                break;  
            }
            
            int sum = nums[i] + nums[L] + nums[R];
            if(Math.abs(sum - target) < Math.abs(ans - target))//更新
                ans = sum;
            // 判断三数之和是否等于target
            if(sum == target) return sum; //最接近值 target
            if(sum > target){//和大了
                R--;
                while(L != R && nums[R] == nums[R+1])//去重
                    R--;
            }
            else{//和小了
                L++;
                while(L != R && nums[L] == nums[L-1])//去重
                    L++;
            }
        }
    }
    return ans;
}
```