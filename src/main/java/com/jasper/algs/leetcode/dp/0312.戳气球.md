<script src="https://cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

## 0312.戳气球

### 问题描述

有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存储在数组 nums 中。

现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得\\(nums[left] \cdot nums[i] \cdot nums[right]\\) 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。

求所能获得硬币的最大数量。

说明:

* 你可以假设 `nums[-1] = nums[n] = 1`，但注意它们不是真实存在的所以并不能被戳破。
* \\(0 \leq n \leq 500, 0 \leq nums[i] \leq 100\\)

示例:

```
输入: [3,1,5,8]
输出: 167 
解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/burst-balloons
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 模板代码

``` java
class Solution {
    public int maxCoins(int[] nums) {

    }
}
```

### 解决方案

从**回溯**法改造为**分治**法，再由分治解法过渡到**动态规划**解法


#### 1. 回溯法


想象解空间的结构：一个n层的数组，每层的元素相同，我们从第一层走到第n层，每层走动时不能使用之前走过的元素。然后按照规则计算获取的金币，我们尝试所有可以走的路径并记录下每条路径所能获得的金币和，最大值即题目的解。在层数不确定的情况下，使用递归比for循环的嵌套更加方便。

因为被戳破的气球等于不存在，我们在计算获得的金币时需要做一点小小的处理。因为气球上的数字是大于等于0的，我们将走过的气球标志为-1。在计算可以获得的金币数时，如果相邻的气球是-1，则略过取相邻的下一个气球即可。另外，出于两边的气球只有一个相邻气球，需要做一下特殊处理。

按上面的思路，这就是一个很简单的搜索问题，但每走一层都会对下面的路径造成影响，所以我们需要通过回溯的手法，每尝试完一种可能性后，在尝试下一种路径前我们都要把之前路径戳破的气球恢复。回溯很简单，只需要加一行代码，即递归调用结束后将当前for循环中戳破的气球恢复。

时间复杂度：\\(\mathrm{O}(n!)\\)

[代码实现](qu0312/solu1/Solution.java)

#### 2. 分治法

当遇到时间复杂度为 \\(n!\\) 的算法时，首先考虑的是使用分治的方式将问题规模缩小。

难点在于，**找到状态转移方程**

$$def(i,j) = max \left( def(i,k) + def(k,j) + nums[i] \cdot nums[j] \cdot nums[k] \right) $$

\\(def(i,j)\\)函数，表示不戳破`i`与`j`，仅戳破`i`与`j`之间的气球，能得到的最大金币数。

\\(k\\)，表示在开区间`(i,j)`中，\\(k\\)是最后一个被戳破的气球。

\\(nums[i] \cdot nums[j] \cdot nums[k]\\)，表示最后一戳，戳破气球`k`，能得到的最大金币数。

**确定回归条件**

因为 k 是介于 i 与 j 之间的，那么当 i 与 j 相邻时，我们的问题将不能再继续划分。此时按照我们对问题的定义，“不戳破 i 与 j ，仅戳破 i 与 j 之间的气球”，因为 i 与 j 之间没有气球，我们得到的金币数是 0 。


[代码实现](qu0312/solu2/Solution.java)


#### 3. 动态规划

方案二加入了缓存避免了子问题的重复计算，已经是一个动态规划解法的雏形。

通常情况下，递归的解法是不可以放在生产环境的，因为我们很难控制问题规模的大小，无法预料何时会有爆栈的风险。

难点在于**找到最优子结构**

[代码实现](qu0312/solu3/Solution.java)
