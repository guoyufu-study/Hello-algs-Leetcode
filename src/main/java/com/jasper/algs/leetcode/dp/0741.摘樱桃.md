## 0741. 摘樱桃

<script src="https://cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

[2刷](qu0741/solu/Solution.java)


### 问题描述

一个 \\(N \\times N\\) 的网格(grid) 代表了一块樱桃地，每个格子由以下三种数字的一种来表示：

* 0 表示这个格子是空的，所以你可以穿过它。
* 1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。
* -1 表示这个格子里有荆棘，挡着你的路。

你的任务是在遵守下列规则的情况下，**尽可能的摘到最多樱桃**：

* 从位置 \\((0, 0)\\) 出发，最后到达 \\((N-1, N-1)\\) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）；
* 当到达 \\((N-1, N-1)\\) 后，你要继续走，直到返回到 \\((0, 0)\\) ，只能向上或向左走，并且只能穿越有效的格子；
* 当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）；
* 如果在 \\((0, 0)\\) 和 \\((N-1, N-1)\\) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。

示例 1:

```
输入: grid =
[[0, 1, -1],
 [1, 0, -1],
 [1, 1,  1]]
输出: 5
```
解释： 
玩家从（0,0）点出发，经过了向下走，向下走，向右走，向右走，到达了点(2, 2)。
在这趟单程中，总共摘到了4颗樱桃，矩阵变成了[[0,1,-1],[0,0,-1],[0,0,0]]。
接着，这名玩家向左走，向上走，向上走，向左走，返回了起始点，又摘到了1颗樱桃。
在旅程中，总共摘到了5颗樱桃，这是可以摘到的最大值了。

说明:

* grid 是一个 \\(N \\times N\\) 的二维数组，N的取值范围是 \\(1 <= N <= 50\\)。
* 每一个 \\(grid[i]\[j]\\) 都是集合 {-1, 0, 1}其中的一个数。
* 可以保证起点 \\(grid[0]\[0]\\) 和终点 \\(grid[N-1]\[N-1]\\) 的值都不会是 -1。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/cherry-pickup
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 模板代码

``` java
class Solution {
    public int cherryPickup(int[][] grid) {

    }
}
```

### 解决方案


#### 贪心算法（错误）

先找到一条樱桃最多的路径走到右下角，然后摘下樱桃，再从摘完后的樱桃地找到最多的樱桃路径返回，摘下樱桃。

#### 1. 动态规划（自顶向下）

从左上角选两条路走到右下角

\\(sum(i,j,k)\\) 表示 机器人在 \\((i, j)\\) 和 \\((i+j-k, k)\\) 两个位置能摘到的樱桃数。

$$
sum(i,j,k) = 
\begin{cases}
grid[i]\[j], & j = k \\\\
grid[i]\[j] + grid[i+j-k]\[k], & j \ne k
\end{cases}
$$


\\(dp(i,j,k)\\) 表示 机器人从 \\((i, j)\\) 和 \\((i+j-k, k)\\) 开始，朝着 \\((N-1, N-1)\\) 走，能摘到最多的樱桃数量。

$$
dp(i, j, k) = 
\begin{cases}
-999, & i, j, (i+j-k), k 有一个越界 \\\\
-999, & grid[i]\[j]=-1 \lor grid[i+j-k]\[k]=-1 （遇到荆棘）\\\\
grid[N-1]\[N-1], & i=N-1, j=N-1, k=N-1 \\\\
sum(i, j, k) + \max \begin{cases}
dp(i+1, j, k) \\\\
dp(i+1, j, k+1) \\\\
dp(i, j+1, k) \\\\
dp(i, j+1, k+1)
\end{cases}, & grid[i]\[j] \ne -1 \land grid[i+j-k]\[k] \ne -1
\end{cases}
$$

[动态规划](qu0741/solu1/Solution.java)

时间复杂度：\\(\mathcal{O}(N^3)\\)

空间复杂度：\\(\mathcal{O}(N^3)\\)

#### 2. 动态规划（自底向上）

状态压缩。假设 \\(i+j=t\\) 是第 \\(t\\) 层。因为递归只能引用下一层，所以一次需要在内存中保留两层。

在第 \\(t\\) 步，\\(dp[i]\[i2]\\) 为两个人从\\((0, 0)\\) 到 \\((i, j)\\) 和 \\((0, 0)\\) 到 \\((i2, k)\\) 能摘到最多樱桃的数量，其中 \\(j = t-i\\), \\(k = t-i2\\)。

[动态规划](qu0741/solu2/Solution.java)

时间复杂度：\\(\mathcal{O}(N^3)\\)

空间复杂度：\\(\mathcal{O}(N^2)\\)
