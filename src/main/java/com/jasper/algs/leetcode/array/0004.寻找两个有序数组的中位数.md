<script src="https://cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

## 0004.寻找两个有序数组的中位数

[5刷](qu0004/solu/Solution.java)

### 问题描述

给定两个大小为 \\(m\\) 和 \\(n\\) 的有序数组 \\(nums1\\) 和 \\(nums2\\)。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 \\(\mathrm{O}(log(m + n))\\)。

你可以假设 \\(nums1\\) 和 \\(nums2\\) **不会同时为空**。

示例 1:

```
nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
```

示例 2:

```
nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
```

中位数（Median）又称中值，是按顺序排列的一组数据中居于中间位置的数。它可以将数值集合划分为相等的上下两部分。如果观察值有偶数个，通常取最中间的两个数值的平均数作为中位数。
中位数 = 中间位置上的数。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。


### 代码模板

``` java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {

    }
}
```

### 解决方案

根据中位数的定义，当 \\(m+n\\) 是奇数时，中位数是两个有序数组中的第 \\(\frac{m+n}{2}\\) 个元素，当 \\(m+n\\) 是偶数时，中位数是两个有序数组中的第 \\(\frac{m+n}{2}\\) 个元素和第 \\(\frac{m+n}{2} + 1\\) 个元素的平均值。


#### 1. 直观思路

##### 暴力归并

使用归并的方式，合并两个有序数组，得到一个大的有序数组。大的有序数组的中间位置的元素，即为中位数。

时间复杂度：\\(\mathrm{O}(m+n)\\)

空间复杂度：\\(\mathrm{O}(m+n)\\)

##### 顺序查找

不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数组的下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标 000 的位置，每次将指向较小值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数的位置。

时间复杂度：\\(\mathrm{O}(m+n)\\)

空间复杂度：\\(\mathrm{O}(1)\\)


#### 2. 二分查找

##### 第k小的数

时间复杂度：\\(\mathrm{O}(\log(m+n))\\)，其中 m 和 n 分别是数组 \\(\text{nums1}\\) 和 \\(\text{nums2}\\) 的长度。初始时有 \\(k=\frac{m+n}{2}\\) 或\\(k=\frac{m+n}{2} + 1\\)，每一轮循环可以将查找范围减少一半，因此时间复杂度是 \\(\mathrm{O}(\log(m+n))\\)。

空间复杂度：\\(\mathrm{O}(1)\\)

##### 中位数特性（推荐）

二分查找，定位 i 和 j。

难点在于边界处理。

时间复杂度：\\(O(\log\min(m,n))\\)，其中 mmm 和 nnn 分别是数组 \\(\text{nums1}\\) 和 \\(\text{nums2}\\) 的长度。查找的区间是 \\([0, m]\\)，而该区间的长度在每次循环之后都会减少为原来的一半。所以，只需要执行 \\(O(\log m))\\) 次循环。由于每次循环中的操作次数是常数，所以时间复杂度为 \\(O(\log m))\\) 。由于我们可能需要交换 \\(\text{nums1}\\) 和 \\(\text{nums2}\\) 使得 \\(m \leq n\\)，因此时间复杂度是 \\(O(\log\min(m,n)))\\)。

空间复杂度：\\(\mathrm{O}(1)\\)

[二分查找+中位数特性](qu0004/solu1/Solution.java)

