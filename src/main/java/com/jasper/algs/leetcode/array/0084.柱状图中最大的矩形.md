<script src="https://cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

## 0084. 柱状图中最大的矩形

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

![histogram](0084_柱状图中最大的矩形_histogram.png)

以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。

![histogram_area](0084_柱状图中最大的矩形_histogram_area.png) 

图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。

 

示例:

```
输入: [2,1,5,6,2,3]
输出: 10
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



### 模板代码


### 解决方案

矩形面积 = 高度 * 宽度；

宽度 = 右边界 - (左边界 - 1)

#### 1. 暴力求解1

**列举每个可能的矩形**

对于两个柱子间矩形，高为它们之间最矮柱子的高度`min`，宽为它们之间的距离`disc`，面积为`min*disc`。

[代码实现](qu0084/solu1/Solution.java)

时间复杂度：\\(\mathrm{O}(n^3)\\)；空间复杂度：\\(\mathrm{O}(1)\\)

#### 2. 暴力求解1：一维DP改进

优化方案1。

动态规划，可以用前一对柱子之间的最低高度来求出当前柱子对间的最低高度。

$$maxHeight_n = max(maxHeight_{n-1}, heights_n)$$

[代码实现](qu0084/solu2/Solution.java)

时间复杂度：\\(\mathrm{O}(n^2)\\)；空间复杂度：\\(\mathrm{O}(1)\\)


#### 3. 暴力求解2

**以某一柱子 i 的高度 heights[i] 为高，求出其尽可能大的矩形面积。**

以某一柱子的高度作为高，要得出尽可能大的矩形面积，需要先定位相应的最左边界、最右边界。

对于某一柱子，其最左边界就是向左看，就一个比它小的柱子右面的那根柱子；其最右边界就是向右看，第一个比它小的柱子左面的那根柱子。

[代码实现](qu0084/solu5/Solution.java)

时间复杂度：\\(\mathrm{O}(n^2)\\)；空间复杂度：\\(\mathrm{O}(1)\\)


#### 4. 暴力求解2改进：单调栈（推荐）

对于方案 3 中“定位最左边界，最右边界”，使用辅助栈进行优化。

我们可以使用单调非递减栈`helper`，缓存那些尚未作为矩形高度进行计算的柱子。

因为栈`helper`是单调非递减的，所以对于柱子`helper[top]`，其最左边界就是柱子`helper[top]+1`。

我们只需要再定位最右边界即可。前面已经说过，最右边界就是向右看，第一个比它小的柱子左面的那根柱子。



[代码实现](qu0084/solu6/Solution.java)

时间复杂度：\\(\mathrm{O}(n)\\)。 n 个数字每个会被压栈弹栈各一次。

空间复杂度： \\(\mathrm{O}(n)\\)。用来存放栈中元素。


#### 5. 分治算法

通过观察，可以发现，最大面积矩形存在于以下几种情况：

1. 以最矮柱子为高，以尽可能往两边延伸为宽的矩形

2. 在最矮柱子左边的最大面积矩形（子问题）。

3. 在最矮柱子右边的最大面积矩形（子问题）。


举个例子：

```
[6, 4, 5, 2, 4, 3, 9]
```

这里最矮柱子高度为 2 。以 2 为高的最大子矩阵面积是 2x7=14 。现在，我们考虑上面提到的第二种和第三种情况。我们对高度为 2 柱子的左边和右边采用同样的过程。在 2 的左边， 4 是最小的，形成区域为 4x3=12 。将左边区域再继续分，矩形的面积分别为 6x1=6 和 5x1=5 。同样的，我们可以求出右边区域的面积为 3x3=9, 4x1=4 和 9x1=9 。因此，我们得到最大面积是 16 。具体过程可参考下图：

![分治算法-求柱状图中最大的矩形](0084_分治-求柱状图中最大的矩形.png)


[代码实现](qu0084/solu3/Solution.java)

时间复杂度：

平均开销：\\(\mathrm{O}(nlogn)\\)

最坏情况：\\(\mathrm{O}(n^2)\\)

空间复杂度：\\(\mathrm{O}(n)\\)。最坏情况下递归需要\\(\mathrm{O}(n)\\) 的空间。


#### 6. 分治算法改进（推荐）

用线段树代替遍历来找到区间最小值。单词查询复杂度就变成了\\(\mathrm{O}(log⁡n)\\)


