<script src="https://cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

## 0070.爬楼梯

### 问题描述

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

示例 2：

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/climbing-stairs
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 模板代码

``` java
class Solution {
    public int climbStairs(int n) {

    }
}
```

### 解决方案

#### 1. 暴力求解

尝试所有可能的组合，成功+1

对于`climbStairs(int i, int n)`方法，当前位于第i层台阶，目标总共有n层台阶，求从第i层台阶开始爬楼，到达第n层台阶，总共有几种方法。

可以将爬法，分成两类：

先爬1个台阶，到i+1层台阶，再继续爬剩下的台阶。`climbStairs(i+1, n)`

先爬2个台阶，到i+2层台阶，再继续爬剩下的台阶。`climbStairs(i+2, n)`

两者相加，`climbStairs(i+1, n) + climbStairs(i+2, n)`，就是从第i层台阶开始爬楼，到达第n层台阶，所有的爬法。

爬楼过程中，当`i>n`时，表示这种爬法组合，失败，终止；当`i==n`时，表示这种爬法组合，成功，`+1`，终止；


[代码实现](qu0070/solu1/Solution.java)



#### 2. 动态规划

这个问题可以被分解为一些包含最优子结构的子问题，即它的最优解可以从其子问题的最优解来有效地构建，我们可以使用动态规划来解决这一问题。

第 i 阶可以由以下两种方法得到：

* 在第 (i-1) 阶后向上爬1阶。

* 在第 (i-2) 阶后向上爬 2阶。

所以到达第 iii 阶的方法总数就是到第 (i−1) 阶和第 (i−2) 阶的方法数之和。

令 dp[i] 表示能到达第 i 阶的方法总数：

dp[i]=dp[i−1]+dp[i−2]


[代码实现](qu0070/solu2/Solution.java)


#### 3. 转换成斐波那契数问题

爬N层，有F(N)种爬法；

F(N)种爬法，分成两类：

1. 先爬1个台阶，再继续爬剩下的N-1层。爬N-1层有F(N-1)种爬法；

2. 先爬2个台阶，再继续爬剩下的N-2层。爬N-2层有F(N-2)种爬法；

所以，F(N) = F(N-1) + F(N-2);

最后，剩下1层，有1种爬法；剩下2层，有2种爬法。

也就是说，本问题可以转换成求斐波那契数，其中F(1)=1; F(2)=2;




### 相关题目 

[0509.斐波那契数](../maths/0509.斐波那契数.md)

