<script src="https://cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

## 0053. 最大子序和

### 问题描述

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

进阶:

* 如果你已经实现复杂度为 \\(\mathrm{O}(n)\\) 的解法，尝试使用更为精妙的分治法求解。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-subarray
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 模板代码

``` java
class Solution {
    public int maxSubArray(int[] nums) {
        
    }
}
```

### 解决方案

#### 1. 暴力求解

构造所有可能的子数组，并求出每个子数组中元素的和。找出最大和。

时间复杂度：\\(\mathrm{O}(n^2)\\)。

空间复杂度：\\(\mathrm{O}(1)\\)。

#### 2. 动态规划

假设 nums 数组的长度是 n，下标从 0 到 n−1。

我们用 \\(a_i\\)​ 代表 nums[i]，用 f(i) 代表以 nums[i] 结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：

$$\max_{0 \leq i \leq n - 1} \\{ f(i) \\} $$

状态压缩后，$$dp_i = \max \\{ dp_{i - 1}, f(i) \\}$$

因此我们只需要求出每个位置的 \\(f(i)\\)，然后返回 f 数组中的最大值即可。

考虑 \\(a_i\\)​ 单独成为一段还是加入 \\(f(i - 1)\\) 对应的那一段，这取决于 \\(a_i\\)​ 和 \\(f(i - 1) + a_i\\) 的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：

$$f(i) = \max \\{ f(i - 1) + a_i, a_i \\} $$

时间复杂度：\\(\mathrm{O}(n)\\)，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。

空间复杂度：\\(\mathrm{O}(1)\\)。我们只需要常数空间存放若干变量。

[动态规划：状态压缩](qu0053/solu2/Solution.java)


#### 3. 贪心算法

如果以当前指针所指元素之前的元素作为结尾的「连续子数组的最大和」小于0，则丢弃当前元素之前的数列。

[贪心算法](qu0053/solu3/Solution.java)

#### 4. 线段树

用于大规模查询的情况。

