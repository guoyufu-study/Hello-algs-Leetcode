<script src="https://cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

## 1326. 灌溉花园的最少水龙头数目

[2刷](qu1326/solu/Solution.java)

### 问题描述

在 x 轴上有一个一维的花园。花园长度为 n，从点 0 开始，到点 n 结束。

花园里总共有 n + 1 个水龙头，分别位于 [0, 1, ..., n] 。

给你一个整数 n 和一个长度为 n + 1 的整数数组 ranges ，其中 ranges[i] （下标从 0 开始）表示：如果打开点 i 处的水龙头，可以灌溉的区域为 \\\([i -  ranges[i], i + ranges[i]]\\) 。

请你返回可以灌溉整个花园的 **最少水龙头数目** 。如果花园始终存在**无法灌溉到**的地方，请你返回 **-1** 。

![1326_灌溉花园的最少水龙头数目_示例1](../../../../../../resources/leetcode/1326_灌溉花园的最少水龙头数目_示例1.png)

示例 1：

```
输入：n = 5, ranges = [3,4,1,1,0,0]
输出：1
```
解释：
点 0 处的水龙头可以灌溉区间 [-3,3]
点 1 处的水龙头可以灌溉区间 [-3,5]
点 2 处的水龙头可以灌溉区间 [1,3]
点 3 处的水龙头可以灌溉区间 [2,4]
点 4 处的水龙头可以灌溉区间 [4,4]
点 5 处的水龙头可以灌溉区间 [5,5]
只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。

示例 2：

```
输入：n = 3, ranges = [0,0,0,0]
输出：-1
```
解释：即使打开所有水龙头，你也无法灌溉整个花园。

示例 3：

```
输入：n = 7, ranges = [1,2,1,0,2,1,0,1]
输出：3
```

示例 4：

```
输入：n = 8, ranges = [4,0,0,0,0,0,0,0,4]
输出：2
```

示例 5：

```
输入：n = 8, ranges = [4,0,0,0,4,0,0,0,4]
输出：1
```

提示：

* \\(1 \le n \le 10^4\\)
* \\(ranges.length == n + 1\\)
* \\(0 \le ranges[i] \le 100\\)

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/minimum-number-of-taps-to-open-to-water-a-garden
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 模板代码

``` java
class Solution {
    public int minTaps(int n, int[] ranges) {

    }
}
```

### 解决方案

#### 1. 动态规划

时间复杂度：\\(\mathrm{O}(NR)\\)，其中 \\(R\\) 是数组 \\(ranges\\) 中的最大值。

空间复杂度：\\(\mathrm{O}(N)\\)。

**思路**

约束灌溉区间。约束后的区间记为 \\([l_i, r_i]\\)，即
$$
l_i = max(i - ranges[i], 0) \\\\
r_i = min(i + ranges[i], n)
$$

绑定区间。对于每一个区间 \\([l_i, r_i]\\)，将它的左端点 \\(l_i\\)绑定在它的右端点 \\(r_i\\) 上，即 \\(prev(r_i) = l_i\\) 表示有一个区间为 \\([l_i, r_i]\\)。如果某一个位置 \\(r_i\\) 有多个要绑定的区间，则取最长区间。如果某一个位置 \\(r_x\\) 没有被绑定区间，给它赋予默认值 \\(prev(r_x) = r_x\\)，它表示有一个区间为 \\([r_x, r_x]\\)，它只覆盖了花园中的一个点，不可能作为答案的一部分，因此这个区间是无效的。

动态规划。令 \\(dp[i]\\) 表示要覆盖花园的子区间 \\([0, i]\\)，并且在选取了右端点 \\(i\\) 绑定的区间 \\([prev(i), i]\\) 的情况下，至少需要选取的区间数目。 \\(dp[n]\\) 为最终的答案。

考虑在选取了区间 \\([prev(i), i]\\) 之后，为了覆盖花园中剩余的部分（即 \\([0, prev(i) - 1]\\)），还需要选取哪些区间。考虑 \\(prev(i) == 0\\) 的特殊情况，如果 \\(prev(i) == 0\\) ，我们只需要一个区间（即 \\([prev(i), i]\\)）就可以覆盖花园中的一段 \\([0, i]\\) 了，即 \\(dp[i]\\) 的值为 1。如果 \\(prev(i) != 0\\) ，那么必须要选取一个右端点在 \\([prev(i), i - 1]\\) 内的区间，因为如果不这样做，\\([prev(i) - 1, prev(i)]\\) 这个长度为 1 的段就不会被任何区间覆盖。状态转移方程：
$$
dp[i] = 
\begin{cases}
0, & i=0 \\\\
1, & i>0, prev[i]=0 \\\\
\min_{prev(i) \leq j \lt i}(dp[j]) + 1，& i>0, prev[i] != 0
\end{cases}
$$

[动态规划](qu1326/solu1/Solution.java)


#### 2. 贪心算法

约束灌溉区间。约束后的区间记为 \\([l_i, r_i]\\)，即
$$
l_i = max(i - ranges[i], 0) \\\\
r_i = min(i + ranges[i], n)
$$

绑定区间。对于每一个区间 \\([l_i, r_i]\\)，将它的右端点 \\(r_i\\)绑定在它的左端点 \\(l_i\\) 上，即 \\(prev(l_i) = r_i\\) 表示有一个区间为 \\([l_i, r_i]\\)。如果某一个位置 \\(l_i\\) 有多个要绑定的区间，则取最长区间。如果某一个位置 \\(l_x\\) 没有被绑定区间，给它赋予默认值 \\(prev(l_x) = l_x\\)，它表示有一个区间为 \\([l_x, l_x]\\)，它只覆盖了花园中的一个点，不可能作为答案的一部分，因此这个区间是无效的。

参考 [0045.跳跃游戏 II](0045.跳跃游戏 II.md) 即可。

[贪心算法](qu1326/solu2/Solution.java)
