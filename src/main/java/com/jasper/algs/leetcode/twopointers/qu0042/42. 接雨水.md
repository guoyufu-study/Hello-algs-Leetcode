## 42. 接雨水

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。

示例:

```
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/trapping-rain-water
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 模板代码

``` java
class Solution {
    public int trap(int[] height) {

    }
}
```

### 解决方案

#### 暴力求解

针对每个柱子`x`，往左右看，定位能看到的最大值`leftMax`和`rightMax`；
两个最大值中的较小值`Math.min(leftMax, rightMax)`，就是当前柱子能达到的最高水位`waterLine`。
当前柱子，能接到的雨水就是`waterLine-x`。

时间复杂度 `O(n^2)`；空间复杂度`O(1)`

#### 两个辅助数组

一个辅助数组，存放往左看时，能看到的最大值；
一个辅助数组，存放往右看时，能看到的最大值；

#### 一个辅助栈

辅助栈：存放往左看时，能看到的最大值；

时间复杂度`O(n)`；空间复杂度：`O(n)`

#### 双指针

``` java
public int trap(int[] heights) {
	if(heights.length<=2) return 0;
	
	int ans = 0;// 结果
	int left = 0, right=heights.length-1;//左右指针
	int leftMax=heights[left], rightMax = heights[right];//左右挡板
	
	while(left<right) {
		// 确定当前最高水位 -> 接雨水 -> 更新指针 -> 更新挡板
		if(leftMax<=rightMax) {
			ans += leftMax - heights[left++];
			leftMax = Math.max(leftMax, heights[left]);
		}
		else {
			ans +=  rightMax - heights[right--] ;
			rightMax = Math.max(rightMax, heights[right]);
		}
		
	}
	
	return ans;
}
```

时间复杂度`O(n)`；空间复杂度：`O(1)`
