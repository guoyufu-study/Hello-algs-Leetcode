<script src="https://cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

## 0463. 岛屿的周长

### 问题描述

给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。

网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

 

示例 :

```
输入:
[
 [0,1,0,0],
 [1,1,1,0],
 [0,1,0,0],
 [1,1,0,0]
]

输出: 16
```

解释: 它的周长是下面图片中的 16 个黄色的边：

![岛屿](../../../../../../resources/leetcode/0463_岛屿的周长.png)

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/island-perimeter
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 模板代码

``` java
class Solution {
    public int islandPerimeter(int[][] grid) {

    }
}
```

### 解决方案

#### 1. DFS 深度优先搜索

标记遍历过的方格，值为 0 表示非岛屿（不可遍历），值为 1 表示岛屿（可遍历），我们用 2 表示已遍历过的岛屿。

每当在 DFS 遍历中，从一个岛屿方格走向一个非岛屿方格，就将周长加 1。

[深度优先搜索](qu0463/solu1/Solution.java)



#### 2. 消去相邻重复边

每个陆地方块，周长为4=4*1。

每次陆地方块相接，周长消 1；

[消去相邻重复边](qu0463/solu2/Solution.java)


#### 3. 求一半(推荐)

只统计上边及左边，下边数 = 上边数，右边数 = 左边数

[只计算一半](qu0463/solu3/Solution.java)

