# 回溯法


## 原理

回溯算法的基本思想是：**从一条路往前走，能进则进，不能进则退回来，换一条路再试**。

### 解决思路

解决一个回溯问题，实际上就是**一个决策树的遍历过程**。你只需要思考 3 个问题：

1. 路径：记录已经做出的选择。

2. 选择列表：当前可以做的选择。

3. 结束条件：到达决策树底层，无法再做选择的条件。


因为在每个节点上都在做决策，所以称其为决策树。

前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行。

回溯算法就是纯暴力穷举，复杂度一般都很高

### 代码框架

写 backtrack 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集。

```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

其核心就是 **在 for 循环里递归，递归前「做选择」，递归后「撤销选择」**，特别简单。

### 常用技巧

#### 偏移量数组

**偏移量数组**是一种经常在二维平面内使用的技巧。


## 具体问题

### 组合总和问题

[0039.组合总和](0039.组合总和.md)

[0040.组合总和 II](0040.组合总和 II.md)

[0216.组合总和 III](0216.组合总和 III.md)

[0377.组合总和 Ⅳ](0377.组合总和 Ⅳ.md)


### N皇后问题

[N皇后问题](leetcode/backtracking/N皇后问题.md)

### 对角线遍历问题

[0498.对角线遍历](0498.对角线遍历.md)

[1424.对角线遍历 II](1424.对角线遍历 II.md)

### 岛屿问题

[岛屿问题](岛屿问题.md)


### 生成括号

[0022.括号生成](0022.括号生成.md)