## 0351. 安卓系统手势解锁

<script src="https://cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

[2刷](qu0351/solu/Solution.java)

### 问题描述

我们都知道安卓有个手势解锁的界面，是一个 3 x 3 的点所绘制出来的网格。

给你两个整数，分别为 ​​m 和 n，其中 1 ≤ m ≤ n ≤ 9，那么请你统计一下有多少种解锁手势，是至少需要经过 m 个点，但是最多经过不超过 n 个点的。

 

先来了解下什么是一个有效的安卓解锁手势:

* 每一个解锁手势必须 **至少** 经过 m 个点、**最多** 经过 n 个点。
* 解锁手势里不能设置经过 **重复的点**。
* 假如手势中有两个点是顺序经过的，那么这两个点的手势轨迹之间是绝对 **不能跨过任何未被经过的点**。
* 经过点的 **顺序** 不同则表示为不同的解锁手势。

 

 

解释:

```
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |
```

无效手势：`4 - 1 - 3 - 6`
连接点 1 和点 3 时经过了未被连接过的 2 号点。

无效手势：`4 - 1 - 9 - 2`
连接点 1 和点 9 时经过了未被连接过的 5 号点。

有效手势：`2 - 4 - 1 - 3 - 6`
连接点 1 和点 3 是有效的，因为虽然它经过了点 2 ，但是点 2 在该手势中之前已经被连过了。

有效手势：`6 - 5 - 4 - 1 - 9 - 2`
连接点 1 和点 9 是有效的，因为虽然它经过了按键 5 ，但是点 5 在该手势中之前已经被连过了。
 

示例:

```
输入: m = 1，n = 1
输出: 9
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/android-unlock-patterns
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。


### 模板代码

``` java
class Solution {
    public int numberOfPatterns(int m, int n) {

    }
}
```

### 解决方案

#### 1. 回溯

[简单实现](qu0351/solu1/Solution.java)

[剪枝优化](qu0351/solu2/Solution.java)

时间复杂度：\\(\mathcal{O}(N)\\)

空间复杂度：\\(\mathcal{O}(1)\\)

#### 2. 动态规划


