# 回溯法


## 原理

回溯算法的基本思想是：**从一条路往前走，能进则进，不能进则退回来，换一条路再试**。

### 解决思路

解决一个回溯问题，实际上就是**一个决策树的遍历过程**。你只需要思考 3 个问题：

1. 路径：记录已经做出的选择。

2. 选择列表：当前可以做的选择。

3. 结束条件：到达决策树底层，无法再做选择的条件。


因为在每个节点上都在做决策，所以称其为决策树。

前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行。

回溯算法就是纯暴力穷举，复杂度一般都很高

### 代码框架

写 backtrack 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集。

```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

其核心就是 **在 for 循环里递归，递归前「做选择」，递归后「撤销选择」**，特别简单。

### 常用技巧

#### 偏移量数组

**偏移量数组**是一种经常在二维平面内使用的技巧。


## 具体问题

### 组合总和问题

[0039.组合总和](0039.组合总和.md)

[0040.组合总和 II](0040.组合总和 II.md)

[0216.组合总和 III](0216.组合总和 III.md)

[0377.组合总和 Ⅳ](0377.组合总和 Ⅳ.md)


### N皇后问题

[0051.N皇后](0051.N皇后.md)

[0052.N皇后 II](0052.N皇后 II.md)

[1222.可以攻击国王的皇后](1222.可以攻击国王的皇后.md)


### 对角线遍历问题

[0498.对角线遍历](0498.对角线遍历.md)

[1424.对角线遍历 II](1424.对角线遍历 II.md)


### 岛屿问题

**网格搜索类问题**

**着色法**

DFS 深度优先搜索 

BFS 广度优先搜索

[0130.被围绕的区域](0130.被围绕的区域.md) - [2刷](qu0130/solu/Solution.java)

[0200.岛屿数量](0200.岛屿数量.md)

[0305.岛屿数量II] - [会员]

[0649.不同岛屿的数量] - [会员]

[0711.不同岛屿的数量II] - [会员]

[1254.统计封闭岛屿的数目](1254.统计封闭岛屿的数目.md)

[0463.岛屿的周长](0463.岛屿的周长.md)

[0695.岛屿的最大面积](0695.岛屿的最大面积.md)

[0827.最大人工岛](0827.最大人工岛.md)

[1020.飞地的数量](1020.飞地的数量.md)




### 生成括号

[0022.括号生成](0022.括号生成.md)