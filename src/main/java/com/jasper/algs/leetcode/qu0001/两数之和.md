# 两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:

```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/two-sum
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 解决方案
### 1. 暴力求解：双层循环

遍历每个元素 `x`，并查找是否存在一个值与 `target - x`相等的目标元素。

假设答案是{i,j}，并且i<j；
我们只需要找出i，就可以简单地遍历余下的数组，找出满足条件`nums[i]+nums[j]=target`的j。

外层循环假设找到了数组索引i，内层循环找出满足条件的j。

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
    	int length = nums.length;
		for (int i = 0; i < length-1; i++) {//假设i
			for (int j = i+1; j < length; j++) {//找出j
                if (nums[i]+nums[j] == target) //条件判断
                    return new int[] {i, j};
            }
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```

时间复杂度O(n^2)，空间复杂度O(1)

### 2. 排序+双指针

时间复杂度O(nlog(n))，空间复杂度O(1)

``` java


```

#### 3. 两遍哈希表：先存再找

为了对运行时间复杂度进行优化，我们需要一种检查数组中是否存在目标元素的更有效的方法。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {//存字典
            map.put(nums[i], i);
        }
        for (int i = 0; i < nums.length; i++) {//查字典
            int complement = target - nums[i];
            if (map.containsKey(complement) && map.get(complement) != i) {
                return new int[] { i, map.get(complement) };
            }
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```

时间复杂度O(n)，空间复杂度O(n)

#### 4. 一遍哈希表：找不到就存

时间复杂度O(n)，空间复杂度O(n)

``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {//查字典
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);//存字典
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```




